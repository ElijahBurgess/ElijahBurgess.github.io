<!DOCTYPE html>
<html>
<head>
	<title>CSV to HTML Table</title>
	<style>
		table {
			border-collapse: collapse;
			width: 100%;
		}

		th, td {
			padding: 8px;
			text-align: left;
			border-bottom: 1px solid #ddd;
		}

		th {
			background-color: #f2f2f2;
			color: #333;
			font-weight: bold;
			cursor: pointer;
		}

		th.sort-asc:before,
		th.sort-desc:before {
			content: "\25b4";
			margin-right: 5px;
		}

		th.sort-desc:before {
			content: "\25be";
		}
	</style>
</head>
<body>
	<h1>My CSV Table</h1>
	<table id="csv-table">
		<thead>
			<tr>
				<th onclick="sortTable(0)">Column 1</th>
				<th onclick="sortTable(1)">Column 2</th>
				<th onclick="sortTable(2)">Column 3</th>
			</tr>
		</thead>
		<tbody>
		</tbody>
	</table>
	
	<script>
		let sortColumn = null;
		let sortAscending = true;

		// Load CSV file and create table rows
		fetch("table2.csv")
			.then(response => response.text())
			.then(data => {
				const rows = data.split("\n");
				const tableBody = document.querySelector("#csv-table tbody");
				
				rows.forEach((row) => {
					const cells = row.split(",");
					const tableRow = document.createElement("tr");
					
					cells.forEach((cell) => {
						const tableCell = document.createElement("td");
						tableCell.innerText = cell;
						tableRow.appendChild(tableCell);
					});
					
					tableBody.appendChild(tableRow);
				});
			})
			.catch(error => console.log(error));
		
		// Sort table by column
		function sortTable(columnIndex) {
			const table = document.querySelector("#csv-table");
			const rows = Array.from(table.querySelectorAll("tbody tr"));
			const sortAscIcon = "\25b4";
			const sortDescIcon = "\25be";

			if (sortColumn === columnIndex) {
				sortAscending = !sortAscending;
			} else {
				sortColumn = columnIndex;
				sortAscending = true;
			}

			rows.sort((rowA, rowB) => {
				const cellA = rowA.querySelectorAll("td")[columnIndex].innerText;
				const cellB = rowB.querySelectorAll("td")[columnIndex].innerText;
				
				if (isNaN(cellA) || isNaN(cellB)) {
					return cellA.localeCompare(cellB);
				} else {
					return parseFloat(cellA) - parseFloat(cellB);
				}
			});

			if (!sortAscending) {
				rows.reverse();
			}
			
			table.querySelector("tbody").innerHTML = "";
			rows.forEach(row => table.querySelector("tbody").appendChild(row));

			// Update sort icons
			const ths = table.querySelectorAll("thead th");
			ths.forEach((th) => {
				th.classList.remove("sort-asc");
				th.classList.remove("sort-desc");
				th.innerHTML = th.innerHTML.replace(sortAscIcon, "");
				th.innerHTML = th.innerHTML.replace(sortDescIcon, "");
			});

			const currentTh = ths[columnIndex];
			if (sortAscending) {
				currentTh.classList.add("				currentTh.classList.add("sort-asc");
				currentTh.innerHTML += sortAscIcon;
			} else {
				currentTh.classList.add("sort-desc");
				currentTh.innerHTML += sortDescIcon;
			}
		}
	</script>
</body>
</html>

